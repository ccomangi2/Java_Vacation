# 수빈이의 자바 스터디북
## 자바 언어의 개요
### 자바 언어의 특징
1. 단순하다.
2. C++을 기반으로한 **객체지향언어**이다.
3. **플랫폼 독립적**이다.
4. 컴파일러와 인터프리터 언어의 두 가지 특징을 모두 갖는다.
5. **분산 처리에 용이**하다.
6. 견고하다.
	- 포인터를 사용하지 않는디.
	- 자동으로 가비지 컬렉션 기능을 수행한다.
	- 엄격한 데이터형 검사를 통해 에러를 조기에 발견한다.
	- 실행 시간에 발생하는 에러를 처리한다.
7. 안전하다.
8. **멀티스레드**를 지원한다.
### 자바 개발 환경 (JDK: Java Development Kit)
- JVM (Java virtual Machine : 자바 가상 머신)
- Java API (Java Application Progeamming Interface)
|종류|특징|
|:-:|:-:|
|J2SE|일반 자바 애플리케이션을 개발하기 위한 기본 자바 개발 환경|
|J2EE|서버 관련 프로그램을 개발하기 위한 자바 개발 환경**(웹 서버 환경)**|
|J2ME|다양한 제품과 임베디드 기기 프로그램을 개발하기 위한 자바 개발 환경 **(모바일)**|
### 자바 프로그램의 종류
1. 일반 프로그램 - 자바 애플리케이션
2. 웹 클라이언트 프로그램 : 애플릿(applet) - 웹 브라우저
3. 웹 서버 프로그램 : 서블릿(sevlet)과 JSP(Java Server pages) - HTML
4. 웹컴포넌트 : EJB(Enterprise Java Beans) - 분산 객체 기술
5. 모바일과 임베디드(embedded) - 휴대폰
### 자바 개발 환경 설치
1. 설치 
	- 윈도우 플랫폼의 자바 개발환경(J2SE JDK)을 다운로드 받기
	[Java 사이트](http://www.oracle.com/kr)
	- 다운로드한 파일을 실행하여 설치하기
	- 자바 개발 환경 폴더 구조 둘러보기
	- 환경 변수 설정하기
	[java 환경 변수 설정하기](https://prolite.tistory.com/975)
|폴더|내용|
|-|-|
|bin|자바 개발 환경과 관련된 명령어가 들어있는 폴더|
|include|플랫폼 별로 필요한 각종 헤더 파일들이 들어있는 폴더|
|jre|자바 실행 환경과 관련된 명령어와 라이브러리가 들어있는 폴더|
|lib|자바 개발 환경에서 사용되는 라이브러리가 들어있는 폴더|
2. 자바 통합 개발 툴
	- 자바 초보자용 : 메모장(notepad), Uitra Edit, Edit plus, J Creator
	- 자바 전문가용 : J Bulider, **Eclipse**, NetBeans
3. 자바 프로그램의 기본 구조
 ```
 public class 클래스이름 {
 	public static void main ( String args[] ) {
 		실행할 명령;
 		/* 여러 줄 주석 */
 		// 한 줄 주석
 	}
 }
 class 클래스이름 {
 	실행할 명령;
 }	
 ```
## 자바 언어의 기본 문법
### 변수
1. 변수 : 데이터가 저장된 기억 공간(주 기억장치)의 이름
	- 알파벳 대.소문자, 숫자, _, $만 사용 할 수 있다.
	- 첫 문자로 숫자는 올 수 없다.
	- 대.소문자를 구분한다,
	- 자바 예약어는 사용 할 수 없다.
	- 길이 제한은 없다.
	- 덮어쓰기가 가능하지만 최종 덮어쓰기가 값
2. 자바 예약어
|abstract|const|finally|interface|return|transient|
|:-:|:-:|:-:|:-:|:-:|:-:|
|assert|continue|float|long|short|true|
|boolean|defult|for|native|static|try|
|break|do|goto|new|super|void|
|byte|double|if|null|switch|colatile|
|cast|else|implements|package|synchronized|while|
|catch|extends|import|private|this||
|char|false|instanceof|protected|throw|||
|class|final|int|public|throws|||
### 데이터형
1. 기본형
|종류|데이터형|바이트 수|범위|
|:-:|:-:|:-:|:-:|
|논리형|boolean|1바이트|true 또는 false|
|단일 문자형|char|2바이트|'\u0000' ~ '\uffff'|
|정수형|byte|1바이트|-2의7 ~ 2의7-1|
||short|2바이트|-2의15 ~ 2의15-1|
||int|4바이트|-2의31 ~ 2의31-1|
||long|8바이트|-2의63 ~ 2의63-1|
|실수형|float|4바이트|1.4e-45 ~ 3.4028235e38|
||double|8바이트|4.9e-324 ~ 1.7976931348623157e308|
2. 오류
 - 컴파일 에러 : 수정이 쉽고 문법이 틀려서 걸리는 경우가 많다.
 - 런타임 에러 : 발견도 수정도 어렵고 문법적으로는 에러가 아니다.
 - 논리 에러 : 에러 메시지가 없고 코딩을 잘못했을 경우가 많다.
3. 데이터 형변환
 - 자동 형 변환(확대 형 변환, 묵시적 형 변환) : 내부적으로 자동으로 수행
 ```
 public class CastingExam1{
 	public static void main(String args[]){
 		byte a = 10;
 		int b = a;		//int b = (int)a; 자동이므로 생략
 	}
 }
 ```
 - 강제 형 변환(축소 형 변환, 명시적 형 변환) : 데이터의 손실 가능성이 있다.
 ```
 public class CastingExam2{
 	public static void main(String args[]){
 		int a = 10;
 		byte b = a;//에러
 		//int형이 더 작은 범위인 byte형으로 변환하려면 형 변환 연산자 사용
 	}
 }
 ```
### 배열
1. 배열 : 같은 종류의 데이터를 여러 개 저장하는 기억 장소
	- 데이터형의 데이터를 여러 개 저장하기 위해 사용
	- 메모리도 정약하면서 쉽고 간결함
	- 참조형 변수
- 1단계 : 배열 선언
```
데이터형 배열변수면[]; 또는 데이터형[] 배열변수명;
				int a[ ];
```
- 2단계 : 배열 생성
```
배열변수명 = new 데이터형[ 배열의 길이 ];
				a = new int[3];
```
- 3단계 : 배열 초기화
```
				a[0] = 10; a[1] = 20; a[2] = 30;
```
1단계 + 2단계
```
데이터형 배열변수명[ ] = new 데이터형[ 배열의 길이 ];
	int a[] = new int[3];
또는
데이터형[ ] 배열변수명 = new 데이터형[ 배열의 길이 ];
	int[] a = new int[3];
```
1단계 + 2단계 + 3단계
```
데이터형[ ] 배열변수명 ] {초기값 나열} ;
	int[] a = {1, 2, 3}; 또는 int[] a = new int[]{1, 2, 3} ;
또는
데이터형[ ] 배열변수명 = new 데이터형[ ]{초기값 나열};
	int a[] = {1, 2, 3}; 또는 int a[] = new int[]{1, 2, 3} ;
```
|데이터형|초기값|
|:-:|:-:|
|byte, short, int|0|
|long|0L|
|float|0.0F|
|double|0.0|
|boolean|false|
|char|'\u0000'|
배열 객체의 원소개수인 길이는 배열객체의 멤버 변수인 length를 통해 알 수 있다.
```
public class ArrayExam9{
	public static void main(String[] args){
		int a[];
		int[] b;
		int[] c = { 31, 32, 33 };
		a= new int[4];
		b = new int[]{ 21, 22, 23, 24 };
		c = b;
		System.out.println(a.length = " " + b.length + " " + c.length);
	}
}
결과 : 4 4 4
설명 : 배열객체 변수 b와 c =는 똑같은 배열객체를 가리키게 된다.
```
2. 이차원 배열 : 배열객체를 원소로 하는 배열
	- 1단계 : 배열 선언
	```
	int[][] a; 또는 int a[][]; 또는 int[] a[];
	```
	- 2단계 : 배열 생성
	```
	a = new int[2][3];
	```
	- 3단계 : 배열 초기화
	```
	a[0][0] = 1; a[0][1] = 2; a[0][2] = 3;
	a[1][0] = 10; a[1][1] = 20; a[1][2] = 30;
	```
	||1열|2열|3열|
	|:-:|:-:|:-:|:-:|
	|1행|1|2|3|
	|2행|10|20|30|
	- 1단계 + 2단계
	```
	int[][] a = new int[2][3];
	int a[][] = new int[2][3];
	int[][] a = new int[2][]; a[0] = new int[3]; a[1] = new int[3];
	```
	- 1단계 + 2단계 + 3단계
	```
	int[][] a = { {1,2,3}, {10,20,30}};
	```
3. 명령행 매개 변수(main())
	- 자바 애프리케이션에 필수적으로 있어야 하는 특수한 메소드
	- 실행될 때 자동으로 호출
	- 문자열을 매개 변수로 받아 프로그램 실행 시 필요한 정보를 프로그램에 전달
	```
	public static void main(String args[]) { }
	String 데이터형을 원소로 하는 배열.
	사용자가 명령행에서 입력한 문자열들은 순서대로 배열 args에 저장.
	```
### 연산자와 우선순위
1. 산술 연산자
|종류|사용법|기능|연산식|결과|
|:-:|:-:|:-:|:-:|:-:|
|+|a + b |덧셈|20 + 10|30|
|-|a - b |뺄셈|20 - 10|10|
|*|a * b |곱셈|20 * 10|200|
|/|a / b |나눗셈|20 / 10|2|
|%|a % b |나머지|20 % 10|0|
2. 관계(비교) 연산자
|종류|사용법|기능|연산식|결과|
|:-:|:-:|:-:|:-:|:-:|
|>|a > b |크다|20 > 10|true|
|>=|a >= b |크거나 같다|20 >= 10|true|
|<|a < b |작다|20 < 10|false|
|<=|a <= b |작거나 같다|20 <= 10|false|
|==|a == b |같다|20 == 10|false|
|!=|a != b |같지 않다|20 != 10|true|
3. 논리 연산자
|종류|사용법|기능|연산식|결과|
|:-:|:-:|:-:|:-:|:-:|
|&|a & b |a와 b가 모두 true인 경우에만 true 반환,나머지 경우는 모두 false 반환|(1>2) & (1<2)|false|
|&&|a && b |a와 b가 모두 true인 경우에만 true 반환,a가 false인 경우는 b를 수행하지 않고 false 반환|(1>2) && (1<2)|flase|
|I|a I b |a와 b중에 하나라도 true면 true 반환, a와 b모두 false면 false 반환|(1>2) I (1<2)|true|
|II|a II b |a와 b 중 하나라도 true면 true 반환, 단, a가 true인 경우는 b를 수행하지 않고 true 반환|(1>2) II (1<2)|true|
|!|a ! b |a가 true이면 false, a가 false이면 true 반환|!(1<2)|false|
4. 증감(증가/감소) 연산자
|종류|사용법|기능|연산식|결과|
|:-:|:-:|:-:|:-:|:-:|
|++|++a|먼저 변수 a값을 1 증가시키고, 수식에 적용|a = 10; b= ++a + 10;|a = 11, b = 21|
||a++|수식에 적용한 후, 나중에 변수 a값을 1 증가|a = 10; b= a++ + 10;|b = 20, a = 11|
|--|--a|먼저 변수 a값을 1 감소시키고, 수식에 적용|a = 10; b= --a + 10;|a = 9, b = 19 |
||a--|수식에 적용한 후, 나중에 변수 a값을 1 감소|a = 10; b= a-- + 10;|b = 20, a = 9|
5. 비트 연산자
	- & 연산은 특정 비트를 0으로 만들기 위해 사용
	- | 연산은 특정 비트를 1로 만들기 위해 사용
	- ^ 연산은 특정 비트를 비트 반전시키기 위해 사용
	- ~ 연산은 1의 보수를 만들기 위해 사용
	- <<, >>> 연산은 비트를 이동시켜 곱셈 나눗셈에 응용
|종류|사용법|기능|연산식|결과|
|:-:|:-:|:-:|:-:|:-:|
|&|a & b |a와 b의 비트 별로 두 비트가 모두 1이면 1, 하나라도 0이면 0 (비트 AND)|00000110 & 11111101|00000100|
|I|a I b |a와 b의 비트 별로 두 비트가 모두 0이면 0, 하나라도 1이면 1 (비트 OR)|00000110 I 00001000|00001110|
|^|a ^ b |a와 b의 비트 별로 두 비트가 서로 다르면 1, 같으면 0 (비트 XOR)|00000110 ^ 00001111|00001001|
|~|a ~ b |a와 b의 비트 별 반전|~00000110|11111001|
|>>|a >> b |a의 비트를 b 비트 수만큼 우측으로 이동|00010100 >> 2|00000101|
|<<|a << b |a의 비트를 b 비트 수만큼 좌측으로 이동|00010100 << 2|01010000|
|>>>|a >>> b |a의 비트를 b 비트 수만큼 우측으로 이동|00010100 >>> 2|00000101|
6. 대입 연산자
|종류|사용법|기능|연산식|결과|
|:-:|:-:|:-:|:-:|:-:|
|=|a = b |b 값을 a에 대입|a=2;|a=2|
|+=|a += b |a 값에 b를 더한 후, 다시 a에 대입 (a=a+b)|a += 2;|a=4|
|-=|a -= b |a 값에 b를 뺀 후, 다시 a에 대입 (a=a-b)|a -= 2;|a=0|
|*=|a *= b |a 값에 b를 곱한 후, 다시 a에 대입 (a=a*b)|a *= 2;|a=4|
|/=|a /= b |a 값에 b를 나눈 후, 다시 a에 대입 (a=a/b)|a /= 2;|a=1|
|%=|a %= b |a 값에 b를 나눈 나머지를, 다시 a에 대입 (a=a%b)|a %= 2;|a=0|
7. 조건 연산자 (삼항 연산자)
|종류|사용법|기능|연산식|결과|
|:-:|:-:|:-:|:-:|:-:|
|?:|조건 ? 처리1 : 처리2|조건이 참이면 처리1을 수행하고, 거짓이면 처리2를 수행|a=2; b=3; c=(a>b)?a: b:|c=3|
8. 연산자 우선순위
||우선순위|연산자|
|:-:|:-:|:-:|
|1|함수 괄호 배열|()[].|
|2|전치|++ -- ~ !|
|3|승제|* / %|
|4|가감|+ -|
|5|비트 이동|<< >> >>>|
|6|비교|< <= > >=|
|7|비교(등식)|== !=|
|8|비트 AND|&|
|9|비트 XOR|^|
|10|비트 OR|I|
|11|논리 AND|&&|
|12|논리 OR|II|
|13|조건|?:|
|14|대입|= 및 축약 대입 연산자|
### 제어문
1. 선택문
	- if문
	```
	- 조건식의 결과에 따라 한 갈래로 분기하는 if문
	if(조건식) {
		실행문 ; //조건식이 참이면 실행
	}
	- 조건식의 결과에 따라 두 갈래로 분기하는 if문
	if(조건식) {
		실행문 ; //조건식이 참이면 실행
	} else {
		실행문 ; //그렇지 않은 나머지 경우(조건식이 거짓이면)에 실행
	}
	```
2. 반복문
	- for문
	```
	for([1초기식]; [2조건식]; [3증감식]) {
		4실행문;
	}
	실행 순서 : 124 324 324 ..... 32
	```
	- while문
	```
	while(1조건식) {
		2실행문;
	}
	실행 순서 : 12 12 12 12 ..... 1
	```
3. 분기문
	- break문 : switch문을 빠져나오거나 반복문에서 가장 가까운 반복 블록을 빠져 나올 때 사용
	- countinue문 : 이후의 문장은 실행하지 않고 그 다음 반복을 계속할 때 사용
## 객체지향의 개요
### 객체지향의 개념
1. 구조체에서는 속성인 멤버 변수만 지정, 행위에 대해서는 procedure(함수)로 구현하여
2. 프로그램 길이가 길어지고 
3. 재 사용성이 거의 없으며
4. 코드가 간결하지 못하다. 
### 객체와 클래스
1. 객체(Object)
	- 사람들이 의미를 부여하고 분류하는 논리적 단위로. 실세계에 존재하는 명사로서의 성질을 갖는 모든 것
	- 실제 프로그램에서 필요한 특성만을 중심으로 모델링
	- 정적인 특성(속성:attribute)과 동적인 특성(메서드:method)로 구성
	- 예) 자동차 객체
	|속성|메서드|
	|-|-|
	|소유자, 마력, 가격, 색상 등|달리다, 정지하다, 연료를 넣다 등|
2. 클래스
	- 객체를 프로그래밍 언어로 정의한 것
	- 동일한 속성과 메서드를 가진 여러 개의 객체를 생성하는 형판
3. 객체 지향 프로그래밍의 3단계
	- 실세계 객체의 모델링
	- 클래스 정의
	- 인스턴스(instance) 객체의 생성 및 사용
예) 자동차 운행에 관련한 클래스 작성
```
1단계 : 자동차 객체 모델링
2단계 : 클래스 정의
Class Car {
	String 모델명;
	String 제조사;
	void speedUp();
	void stop();
}
3단계 : 인스턴스 객체의 생성 및 사용
Car morining = new Car(“모닝”, “현대”);
morning.speedUp();
morning.stop();
```
### 객체 지향 언어의 특징
1. 갹체지향 프로그래밍의 특징
	- 대규모 프로젝트 개발에 유연하게 적용
	- **캡슐화 (자료 추상화)** - 자료 추상화는 객체 내부에서만 알고 있어야 하는 정보는 숨기고 외부에 보여야 할 정보만을 표현함으로써 프로그램을 간단히 만드는 것이다. 객체를 사용하는 측에서는 캡슐화된 속성과 메서드가 실제 어떻게 처리되는지는 알 필요없이, 단지 **객체를 사용할 수 있는 인터페이스를 통해 사용만 하면 된다.** (접근제어자나 인터페이스의 사용 등 다양한 객체 지향 프로그래밍 기법을 통해 캡슐화를 할 수 있다.)
	- **상속** – **상속은 새로운 클래스가 기존의 클래스의 자료와 연산을 이용할 수 있게 하는 기능**이다. 만약 정의하려는 클래스가 이미 정의된 클래스가 갖는 속성과 메서드에 약간의 속성과 메서드가 추가되어야 한다면 기존의 클래스를 상속받아 새로 필요한 속성과 메서드를 추가한다.
	- **다형성** – **여러 개의 형태를 갖는다는 의미로 메서드 형태가 다양하거나, 동일한 이름의 메서드가 약간씩 다른 의미를 가질 수 있다는 것을 뜻한다.** 객체 지향 언어에서는 메드 오버로딩과 메서드 오버라이딩이 다형성이 적용된 대표적인 예이다. 오버로딩은 메서드 중복 정의, 오버라이딩은 메서드 재정의를 뜻한다.
      메서드 오버로딩의 예 : 삼각형.면적구하기(밑변, 높이), 원.면적구하기(반지름)
      메서드 오버라이딩의 예 : 택시.연료를 넣다(), 트럭.연료를 넣다(), 전지차.연료를 넣다()
	- **메시지패싱** – 인스턴스 객체간 통신하는 방법으로 메시지를 주고 받는다.
2. 다형성 실습
	- **오버로딩** : 하나의 클래스에서 동일한 이름의 메소드가 매개변수의 개수나 타입을 달리해서 여러 가지 형태로 존재
	- **오버라이딩** : 상속관계에 있는 하위 클래스가 상위 클래스의 메소를 재정의 하는 것
## 클래스
### 클래스의 정의
> 클래스
> > 클래스 선언부
> > 클래스 멤버
> > > 생성자
> > > 멤버 변수
> > > 메소드
> > > 내부 클래스
### 객체 생성
- 1단계 : 객체참조형 변수 선언
```
클래스형 객체변수명;
		Student kim;
```
- 2단계 : 객체생성
```
객체변수명 = new 생성자();
		kim = new Student()
```
- 1단계 + 2단계
```
클래스 형 객체 변수명 = new 생성자();
		Student kim = new Student();
```
### 멤버 변수(객체속성변수)
- 클래스를 정의할 때 메서드 밖에 선언하는 변수
- 객체가 가질 수 있는 정적인 속성을 나타냄
```
형식
[접근제어자] [static/final] 데이터형 변수명 ;
```
- static : 클래스변수
- final : 최종의
- final 변수 : 상수
- final 메서드 : 재정의 불가능한 메서드
- final 클래스 : 상속이 불가능한 클래스
- 접근제어자 : public protected, private
1. 접근 권한
|접근제어자|클래스|하위 클래스|동일 패키지|모든 클래스|설명|
|:-:|:-:|:-:|:-:|:-:|:-:|
|private|O|X|X|X|자신 클래스 안에서만 사용 할 수 있는 멤버 선언|
|(default)|O|X|O|X|접근 권한 modifier를 지정 하지 않은 경우, 동일 패키지의 클래스에서만 접근 가능|
|protected|O|O|O|X|동일 패키지의 클래스 또는 동일 패키지는 아니지만 하위 클래스 관계인 클래스에서만 접근 가능|
|public|O|O|O|O|모든 클래스에서 접근 가능|
2. 객체 참조 변수(reference)
	- 인스턴스를 만들어서 사용할 경우 제가 선언하지 않은 메서드나 속성이 코드힌트로 뜹니다.
	- Object는 자바의 최상위 클래스로서 사용자 클래스는 모두 Object를 상속한다.
	- 몇 가지 Object의 메서드는 클래스 생성시 오버라이딩(재정의)해서 사용한다,
	- equals() 메서드 : 내용비교
	- toString() 메서드 : 객체의 클래스 이름과 메모리 참조 내용을 문자열로 리턴하며, print 메서드에 참조형 변수 이름을 사용하면 자동호출 (정말 많이 씀)
   활용) public void toString(){......}=> point 등의 예제를 toString을 이용하여 변경
	- clone()메서드 등 : 객체의 복제에 이용
참고 : 자바의 최상위 클래스 Object
3. 클래스 변수
	- 전역변수(golbal object) 의 개념
	- 클래스가 로딩되는 과정에서 **기억 공간이 한번만 확보**
	- 해당 클래스의 **모든 객체(인스턴스)가 변수를 공유**한다.
	- 객체들 사이의 통신이나 **공통되는 속성**을 표현하는데 사용한다.
	- 일반 변수가 객체이름으로 접근하는데 반해 클래스 변수는 클래스 이름으로 접근한다.
	- 클래스의 접근제어자
		- **public** : 모든 클래스에서 접근이 가능
		- **final** : 하위클래스를 가질 수 없는 클래스. 즉 final로 선언된 클래스로부터는 새로운 클래스가 상속되어 생성될 수 없음을 의미
		- **abstract** : 추상 클래스로 객체를 생성할 수 없는 클래스를 의미
			-참고 : 클래스의 접근제어자의 경우 main()메서드를 가지는 클래스에만 public을 사용한다.
		- **private**는 **상속 불가능**(상속 관계라 해도 상위 클래스에 접근이 불가능)
		- 접근제어자 안 쓰거나 protected(같은 패키지가 아니더라도 상속된 클래스에서 접근 가능), public(아무 문제 없음)을 사용하면 가능
	- 활용 방법
		- **final** : 하위클래스에서 오버라이딩 될 수 없음.
		- **abstract** : 추상 메소드로 추상클래스는 선언부분만 가지고 몸체는 가질 수 없다. 몸체는 서브클래스에서 오버라이딩 됨. 따라서 추상 클래스를 통해서 인스턴스 객체를 생성할 수 없다.
		- **synchronized** :스레드를 동기화 할 수 있는 기법을 제공하기 위해 사용됨
4. 상수 : **final**이 붙으면 해당 멤버 변수는 **더 이상 값을 변경할 수 없다**. (**대문자** 사용)
### 클래스와 인스턴스 객체 생성 예제
멤버변수만 갖는 클래스의 예
```
class Mybox {
	int width;
	int height;
	int depth;
}
class Student {
	public String name;
	public int grade;
	int number;
	String telephone;
	//접근제어자 public을 갖는 변수는 어떤 클래스에서도 접근이 가능하다.
```
멤버변수와 메서드를 갖는 클래스의 예
```
class Box {
	//멤버변수
	int width;
	int height;
	int depth;

	//메서드
	public void volume(int width, int height, int depth){
	 int volume;
	 volume = width*height*depth;
	 System.out.println(“부피” + volume);
	}
```
1. 멤버변수만 있는 클래스 -> 접근제어자 활용 유의 -> 서로 다른 패키지
2. 멤버변수와 메서드를 갖는 클래스 -> 메서드 오버로딩 및 매개변수 유의
3. 멤버변수, 메서드, 생성자메서드(인스턴스 생성)
### 생성자
1. 생성자 정의
	- 생성자는 클래스로부터 객체를 생성할 대 객체의 초기화 과정을 기술하는 특수한 메소드
```
생성자의 특징
1. **new 연산자**와 함께 사용되며 객체 생성 시에 호출된다.
2. 객체 생성 시에 객체의 멤버변수를 **초기화**하는 일을 주로 한다.
3. 생성자 이름은 **클래스 이름과 동일**하며, 일반적으로 **첫 문자는 대문자**이다.
4. **return 유형이 없다.**
5. 생성자가 없는 클래스는 **자바 가상 머신(JVM)이 자동으로 삽입하는 기본 생성자**를 갖는다.
6. 사용자가 정의한 생성자가 있을 경우에는 JVM이 삽입한 기본 생성자는 자동으로 없어진다.
```
2. 생성자 오버로딩
	- 클래스는 매개 변수의 개수, 타입, 순서를 달리하는 같은 이름의 생성자를 여러 개 정의 할 수 있으며 이를 생성자 오버로딩 이라고 한다.
	- 다형성이 구현될 수 있다.
3. this
	- 현재 생성되어 사용 중인 객체의 자신을 의미한다.
### 메소드와 오버로딩
1. 메소드란?
	- 클래스가 가지는 동적인 특성인 행위를 정의한다.
	- 특정한 일을 수행하는 클래스의 주요 구성 요소
	- 특정 작업을 수행하는 자바 문들의 모음
	- 메소드내에서 사용하는 변수를 지역 변수라고 하며 메소드 실행이 끝나며 형식 매개 변수는 메모리에서 사라진다.
	- 메소드는 선언과 호출 부분이 있어야 한다.
		- 호출을 하면 선언부분으로 가서 실행하고, 실행이 종료된 후 호출 다음 부분으로 돌아온다.
> 메소드에서 사용되는 접근 제어자
|구분|접근 제어자|설명|
|:-:|:-:|:-:|
|접근권한|public|모든 클래스에서 접근 가능|
||(default)|지정하지 않은 경우로, 동일 패키지에서만 접근 가능|
||protected|동일 패키지의 클래스와 하위 클래스 관계에 있는 클래스에서만 접근 가능|
||private|자신 클래스 안에서만 접근 가능|
|활용방법|final|오버라이딩이 불가능한 메소드 정의 (상속 관련)|
||static|클래스 메소드|
||abstract|추상 메서드로, 하위 클래스에 의해 구현 (상속 관련)|
||synchronized|스레드 동기화를 위한 메소드이다.|
## 상속
### 상속의 개요
- 상속 : 기존에 있는 클래스의 멤버 변수나 메소드를 물려받아 새로운 클래스를 만드는 것
	- 코드의 재사용성을 구현
	- "is-a 관계"
> 클래스 정의의 예
|클래스명|자동차|택시|트럭|
|:-:|:-:|:-:|:-:|
|멤버변수|차 기종, 색상, 제조회사, 속도|미터기|무게(ton)|
|메소드|속도를 올리다, 속도를 내리다, 출발하다, 정지하다|미터기를 올리다, 미터기를 내리다|짐을 싣다, 짐을 내리다|
1. 상속 방법
	- extends 키워드 사용
	- 단일 상속만을 지원
	- extends 뒤에 하나의 클래스명만 쓸 수 있다.
```
[접근제어자] class 클래스 이름 extends 상위 클래스명
```
	- 모든 클래스는 extends Object를 기술하지 않아도 Object 클래스를 자동으로 상속받는다.
### 상속과 생성자
1. 상속과 범위
메소드 호출의 기본 원칙 : 한 클래스에서 한 메소드가 호출되면
	- 클래스 내에 정의된 메소드인지 확인(있으면 클래스 내의 것을 실행)
	- 아니라면 상위 메소드에 정의된 메소드인지 확인
	- 최상위에 도달할 때까지 계속된다.
상위 클래스의 생성자메서드는 하위 클래스에 자동으로 상속되지 않는다.
어떤 클래스에 생성자메서드를 정의하지 않는다면 컴파일러는 기본 생성자메서드 메소드를 추가한다.
```
class Myclass{
	public void printHello(){
		System.out.println(“Hi”);
	}
}
class Myclass{
	MyClass(){	//
		super();// 컴파일러 자동생성
	}			//
public void printHello(){
	System.out.println(“Hi”);
}
```
따라서 다음의 두 코드는 같은 결과이다. super();는 상위 클래스의 생성자메서드 메소드를 호출하며, 상위 클래스의 생성자메서드 메소드가 없다면 최상위인 Object 클래스의 메소드를 호출한다.
	- 상속 시 유의점
		- 하위 멤버변수를 재정의시 상위 멤버변수 덮어쓴다.
		- 클래스, 메서드, 변수 => 상속 시 접근제어자 private은 사용불가
		- 메서드는 자동 상속 => 실행 시 위로 찾아 올라간다.
		- 생성자 메서드는 자동 상속× => 상위클래스를 이용하려면 super(); 사용
		- super(); => JVM 자동 삽입 => 상위클래스에 매개변수 없는 생성자 메서드를 만들어라.
2. 예약어 super
	- 상위 클래스의 변수나 메소드를 참조하기 위해 사용하는 예약어
```
super.xxx :상위 클래스의 변수 xxx를 나타냄
super.xxx() :상위 클래스의 xxx라는 메소드를 호출
```
3. 메소드 오버라이딩
	- 상위 클래스의 메소드를 하위 클래스에서 재정의하여 사용하는 것
	- 상위 클래스 메소드의 이름, 인자, 반환형에 대해서 완전히 같아야 한다.
	- Static, final, private 메소드의 경우 오버라이딩 할 수 없다.
## 추상 클래스와 인터페이스
### 추상 클래스
1. 클래스 계층구조에서 일반적인 개념을 나타내는 클래스로 하나 이상의 추상 메서드를 포함한다.
	- abstract 키워드를 사용하여 표시한다.
2. 추상 메서드는 메서드 머리 부분만 있고 몸체는 없는 메서드다.
3. 추상 메서드를 가진 클래스로 new 연산자를 이용해 객체를 생성할 수 없다.
4. 추상 클래스의 추상 메서드는 반드시 오버라이딩 되어야 하기 때문에 하위 클래스들이 특정 메서드를 반드시     구현하도록 강제할 수 있다.
5. 추상 메서드를 오버라이딩 하지 않으면 상속받는 클래스도 자동으로 추상 클래스가 된다.
6. 추상메서드도 오버라이딩의 일반적인 규칙을 따른다.
- 추상메서드가 있어야함
- 인스턴스 생성 불가
- 머리 부분만 있음
```
접근 제어자 abstract 리턴타입 메서드이름(); //{}가 없다.
```
### 인터페이스
1. 모든 메소드가 추상 메소드이다.
2. 데이터는 final static 변수만을 가지는 특별한 형태의 클래스이다.
3. 인터페이스를 적용한 클래스는 인터페이스에서 선언된 메소드를 모두 구현해 주어야 한다.
4. **현재의 클래스가 이미 다른 클래스로부터 상속을 받고 있는 상태이면서, 또 다른 클래스의 요소들이 필요할 때 사용**
> 인터페이스를 정의하는 형식
```
public interface 인터페이스명{
	public 메소드 이름(인자들);
}
```
> 인터페이스를 클래스에 구현하는 형식
```
class 클래스명 implements 인터페이스명{
	..............
}
```
> 인터페이스 상속 형식
```
public interface 인터페이스 이름 extends 상위 인터페이스 이름
```